#INFO: **** input file is /Users/jmhrzz/HPQC/TEMP/RandomThoughts/FC/UHF/N/6-31G/CoreFreeze.py ****
import pyscf
import numpy as np
import warnings
from functools import reduce
from pyscf import gto
from pyscf.gto.basis import parse_gaussian
from pyscf.mp.mp2 import get_frozen_mask
from pyscf import lib, ao2mo
from pyscf.scf import atom_hf
from pyscf import __config__

#np.set_printoptions(threshold=np.inf, formatter={'float_kind':lambda x: f"{x: .20E}"})
np.set_printoptions(threshold=np.inf)

def _normalize_spin_masks(mask, nmo):
    if isinstance(mask, (tuple, list)) and len(mask) == 2:
        ma = np.asarray(mask[0], dtype=bool)
        mb = np.asarray(mask[1], dtype=bool)
    else:
        m = np.asarray(mask, dtype=bool)
        if m.size == 2 * nmo:
            ma = m[:nmo].copy()
            mb = m[nmo:].copy()
        elif m.size == nmo:
            ma = mb = m.copy()
        else:
            raise ValueError(f"Mask length {m.size} not compatible with nmo={nmo}.")
    return ma, mb

def freezeCore(oneBody_a, oneBody_b, twoBody_a, twoBody_b, twoBody_ab, frozen_core, active=None):
    nmo_a = np.asarray(oneBody_a).shape[0]
    nmo_b = np.asarray(oneBody_b).shape[0]
    if nmo_a != nmo_b:
        raise ValueError(f"Different nmo in oneBody_a ({nmo_a}) and oneBody_b ({nmo_b}).")
    nmo = nmo_a
    core_a, core_b = _normalize_spin_masks(frozen_core, nmo)
    if active is None:
        valence_a = ~core_a
        valence_b = ~core_b
    else:
        valence_a, valence_b = _normalize_spin_masks(active, nmo)
    assert core_a.shape == (nmo,) and core_b.shape == (nmo,)
    assert valence_a.shape == (nmo,) and valence_b.shape == (nmo,)
    core_idx_a = np.where(core_a)[0]
    core_idx_b = np.where(core_b)[0]
    val_idx_a  = np.where(valence_a)[0]
    val_idx_b  = np.where(valence_b)[0]
    constant   = np.einsum('ii->', oneBody_a[np.ix_(core_idx_a, core_idx_a)])
    constant  += np.einsum('ii->', oneBody_b[np.ix_(core_idx_b, core_idx_b)])
    core_aa    = twoBody_a[np.ix_(core_idx_a, core_idx_a, core_idx_a, core_idx_a)]
    core_bb    = twoBody_b[np.ix_(core_idx_b, core_idx_b, core_idx_b, core_idx_b)]
    core_ab    = twoBody_ab[np.ix_(core_idx_a, core_idx_a, core_idx_b, core_idx_b)]
    constant  += 0.5 * ( np.einsum('iijj->', core_aa) - np.einsum('ijji->', core_aa)
              + np.einsum('iijj->', core_bb) - np.einsum('ijji->', core_bb)
              + 2.0 * np.einsum('iijj->', core_ab) )
    
    h_active_a = oneBody_a[np.ix_(val_idx_a, val_idx_a)].copy()
    coul_aa = twoBody_a[np.ix_(val_idx_a, val_idx_a, core_idx_a, core_idx_a)]
    coul_ab = twoBody_ab[np.ix_(val_idx_a, val_idx_a, core_idx_b, core_idx_b)]
    h_active_a += np.einsum('pqkk->pq', coul_aa)
    h_active_a += np.einsum('pqkk->pq', coul_ab)
    exch_aa = twoBody_a[np.ix_(val_idx_a, core_idx_a, core_idx_a, val_idx_a)]
    h_active_a -= np.einsum('pkkq->pq', exch_aa)
    
    h_active_b = oneBody_b[np.ix_(val_idx_b, val_idx_b)].copy()
    coul_bb = twoBody_b[np.ix_(val_idx_b, val_idx_b, core_idx_b, core_idx_b)]
    h_active_b += np.einsum('pqkk->pq', coul_bb)
    twoBody_ab_T = twoBody_ab.transpose(2,3,0,1)
    coul_ba = twoBody_ab_T[np.ix_(val_idx_b, val_idx_b, core_idx_a, core_idx_a)]
    h_active_b += np.einsum('pqkk->pq', coul_ba)
    exch_bb = twoBody_b[np.ix_(val_idx_b, core_idx_b, core_idx_b, val_idx_b)]
    h_active_b -= np.einsum('pkkq->pq', exch_bb)
    
    twoBody_active_a  = twoBody_a[np.ix_(val_idx_a, val_idx_a, val_idx_a, val_idx_a)].copy()
    twoBody_active_b  = twoBody_b[np.ix_(val_idx_b, val_idx_b, val_idx_b, val_idx_b)].copy()
    twoBody_active_ab = twoBody_ab[np.ix_(val_idx_a, val_idx_a, val_idx_b, val_idx_b)].copy()
    
    return h_active_a, h_active_b, twoBody_active_a, twoBody_active_b, twoBody_active_ab, constant

def main():
    from pyscf import gto, scf, ao2mo
    name = 'out'
    mol = pyscf.M(
        atom='N',
        unit='angstrom',
        basis={'N': parse_gaussian.load('N-6-31G-EMSL.gbs', 'N')},
        charge=0,
        spin=3,
        verbose=9,
        symmetry=True,
        output=name + '.txt',
        symmetry_subgroup='D2h',
        max_memory=4000,
    )

    original_AtomSphAverageRHF = atom_hf.AtomSphAverageRHF

    class CustomAtomSphAverageRHF(original_AtomSphAverageRHF):
        def __init__(self, mol):
            super().__init__(mol)
            self.max_cycle = 9999
            self.direct_scf = False

    atom_hf.AtomSphAverageRHF = CustomAtomSphAverageRHF
    mymf = mol.UHF().set(
        conv_tol=1e-14,
        max_cycle=9999,
        ddm_tol=1e-15,
        direct_scf=False,
        chkfile=name + '.chk',
        init_guess='atom',
        irrep_nelec={'Ag': 4, 'B3u': 1, 'B2u': 1, 'B1u': 1}
    )
    
    mymf.kernel()
    atom_hf.AtomSphAverageRHF = original_AtomSphAverageRHF
    
    def compute_mo_irreps(mol, mo_coeff):
        symm_orbs = mol.symm_orb
        irrep_labels = mol.irrep_name
        mo_irreps = []
        for mo in mo_coeff.T:
            projections = [np.linalg.norm(symm_orbs[i].T @ mo) for i in range(len(symm_orbs))]
            irrep_idx = np.argmax(projections)
            mo_irreps.append(irrep_labels[irrep_idx])
        return mo_irreps

    
    def align_beta_orbitals_to_alpha(mol, mo_coeff):
        alpha_orbs, beta_orbs = mo_coeff[0], mo_coeff[1]
        alpha_irreps = compute_mo_irreps(mol, mo_coeff[0])
        beta_irreps = compute_mo_irreps(mol, mo_coeff[1])
        beta_orbs_sorted = []
        used_indices = set()
        for target_irrep in alpha_irreps:
            for idx, beta_irrep in enumerate(beta_irreps):
                if beta_irrep == target_irrep and idx not in used_indices:
                    beta_orbs_sorted.append(beta_orbs[:, idx])
                    used_indices.add(idx)
                    break
            else:
                raise ValueError(f"No matching beta orbital found for alpha irrep: {target_irrep}")
        beta_orbs_sorted = np.column_stack(beta_orbs_sorted)
        return alpha_orbs, beta_orbs_sorted
    
    mo_coeff = mymf.mo_coeff
    mol = mymf.mol
    
    alpha_irreps = compute_mo_irreps(mol, mo_coeff[0])
    beta_irreps = compute_mo_irreps(mol, mo_coeff[1])
    print(alpha_irreps)
    print(beta_irreps)
    
    assert mo_coeff[0].dtype == np.double and mo_coeff[1].dtype == np.double
    
    mo_coeff_a, mo_coeff_b = align_beta_orbitals_to_alpha(mol, mo_coeff)
    
    mymf.mo_coeff = (mo_coeff_a, mo_coeff_b)
    
    alpha_irreps = compute_mo_irreps(mol, mo_coeff_a)
    beta_irreps = compute_mo_irreps(mol, mo_coeff_b)
    print(alpha_irreps)
    print(beta_irreps)
    
    from pyscf import cc
    mycc = cc.UCCSD(mymf, frozen=1)
        
    orbsym_full = getattr(mo_coeff_a, 'orbsym', None)
    nuc = mymf.energy_nuc()
    
    nmo = mo_coeff_a.shape[0]
    
    h1e_a  = reduce(np.dot, (mo_coeff_a.T, mymf.get_hcore(), mo_coeff_a))
    h1e_b  = reduce(np.dot, (mo_coeff_b.T, mymf.get_hcore(), mo_coeff_b))
    
    eri_a  = ao2mo.restore(1,ao2mo.incore.general(mymf._eri,(mo_coeff_a, mo_coeff_a, mo_coeff_a, mo_coeff_a),compact=False),nmo)
    eri_b  = ao2mo.restore(1,ao2mo.incore.general(mymf._eri,(mo_coeff_b, mo_coeff_b, mo_coeff_b, mo_coeff_b),compact=False),nmo)
    eri_ab = ao2mo.restore(1,ao2mo.incore.general(mymf._eri,(mo_coeff_a, mo_coeff_a, mo_coeff_b, mo_coeff_b),compact=False),nmo)
    print(eri_a)

    active = get_frozen_mask(mycc)
    active_in = active

    mo_occ_obj = getattr(getattr(mycc, '_scf', None) or getattr(mycc, 'mf', None) or mycc, 'mo_occ', None)
    if isinstance(mo_occ_obj, np.ndarray) and mo_occ_obj.ndim == 2 and mo_occ_obj.shape[0] == 2:
        mo_occ_a = mo_occ_obj[0]
        mo_occ_b = mo_occ_obj[1]
    elif isinstance(mo_occ_obj, (list, tuple)) and len(mo_occ_obj) == 2:
        mo_occ_a = np.asarray(mo_occ_obj[0])
        mo_occ_b = np.asarray(mo_occ_obj[1])
    else:
        mo_occ_a = mo_occ_b = np.asarray(mo_occ_obj)

    nmo = mo_occ_a.size

    if isinstance(active_in, (tuple, list)) and len(active_in) == 2:
        act_a = np.asarray(active_in[0], dtype=bool)
        act_b = np.asarray(active_in[1], dtype=bool)
    else:
        act = np.asarray(active_in, dtype=bool)
        if act.size == 2 * nmo:
            act_a = act[:nmo].copy()
            act_b = act[nmo:].copy()
        elif act.size == nmo:
            act_a = act_b = act.copy()
        else:
            raise ValueError(f"Unexpected active length {act.size}; expected {nmo} or {2*nmo}")
        
    shared = np.asarray(act_a, dtype=bool) & np.asarray(act_b, dtype=bool)
    
    act_a[:] = shared
    act_b[:] = shared
    
    active_full = np.empty(2 * nmo, dtype=bool)
    active_full[:nmo] = act_a
    active_full[nmo:] = act_b
    active = active_full
    frozen_core = np.zeros_like(active, dtype=np.bool_)
    nocc_full = mol.nelectron // 2
    frozen_core[:nocc_full] = ~active[:nocc_full]

    nocc_a = int(np.count_nonzero(np.asarray(mo_occ_a) > 0.5))
    nocc_b = int(np.count_nonzero(np.asarray(mo_occ_b) > 0.5))

    frozen_core_a = np.zeros_like(act_a, dtype=bool)
    frozen_core_b = np.zeros_like(act_b, dtype=bool)

    frozen_core_a[:nocc_a] = ~act_a[:nocc_a]
    frozen_core_b[:nocc_b] = ~act_b[:nocc_b]

    h1e_a, h1e_b, eri_a, eri_b, eri_ab, constant = freezeCore(h1e_a, h1e_b, eri_a, eri_b, eri_ab, frozen_core=(frozen_core_a, frozen_core_b), active=(act_a, act_b))
    
    nmo_active = h1e_a.shape[0]

    if orbsym_full is None:
        orbsym_active = None
    else:
        orbsym_arr = np.asarray(orbsym_full, dtype=int)
        valence_idx = np.where(act_a)[0]
        orbsym_active = [int(x) for x in orbsym_arr[valence_idx]]
        
    if orbsym_active is not None:
        if len(orbsym_active) != nmo_active:
            raise RuntimeError(f"Length mismatch: orbsym_active has length {len(orbsym_active)} "
                               f"but number of active orbitals is {nmo_active}.")

    filename = 'fort.55'
    nelec_full = mol.nelectron
    spin = mol.spin       
    nalpha_full = (nelec_full + spin) // 2
    nbeta_full  = (nelec_full - spin) // 2
    nocc_full = mol.nelectron // 2
    nfrozen_core = int(np.count_nonzero(frozen_core[:nocc_full]))
    nalpha_active = nalpha_full - nfrozen_core
    nbeta_active  = nbeta_full  - nfrozen_core
    nelec_active = (nalpha_active, nbeta_active)
    
    
    DEFAULT_FLOAT_FORMAT = getattr(__config__, 'fcidump_float_format', ' %.16g')
    TOL = getattr(__config__, 'fcidump_write_tol', 1e-15)
    
    def write_hcore_uhf(fout, h1e_a, h1e_b, nmo, tol=TOL, float_format=DEFAULT_FLOAT_FORMAT):
        h1e_a = h1e_a.reshape(nmo,nmo)
        h1e_b = h1e_b.reshape(nmo,nmo)
        indx = [i+1 for i in range(nmo)]
        output_format = float_format + ' %5d %5d     0     0\n'
        for i in range(nmo):
            for j in range(i, nmo):
                if abs(h1e_a[i,j]) > TOL:
                    fout.write(output_format % (h1e_a[i,j], indx[i], indx[j]))
        fout.write(' 0.00000000000000000000E+00' + '     0     0     0     0\n')
        for i in range(nmo):
            for j in range(i, nmo):
                if abs(h1e_b[i,j]) > TOL:
                    fout.write(output_format % (h1e_b[i,j], indx[i], indx[j]))
        fout.write(' 0.00000000000000000000E+00' + '     0     0     0     0\n')
    
    print("DEBUG: eri shapes / dtypes")
    print("eri_a.shape =", np.asarray(eri_a).shape, "dtype=", np.asarray(eri_a).dtype)
    print("eri_b.shape =", np.asarray(eri_b).shape, "dtype=", np.asarray(eri_b).dtype)
    print("eri_ab.shape=", np.asarray(eri_ab).shape, "dtype=", np.asarray(eri_ab).dtype)
    print("sample eri_a[0,0,0,0] =", np.asarray(eri_a).flatten()[0] if np.asarray(eri_a).size>0 else None)
    
    
    def write_eri_uhf(fout, eri_a, eri_b, eri_ab, nmo, tol=TOL, float_format=DEFAULT_FLOAT_FORMAT):
        eri_a = np.asarray(eri_a)
        eri_b = np.asarray(eri_b)
        eri_ab = np.asarray(eri_ab)
        npair = nmo * (nmo + 1) // 2
        output_format = float_format + ' %5d %5d %5d %5d\n'
        indx = [i + 1 for i in range(nmo)]
        
        def pair_index(i, j):
            return i * (i + 1) // 2 + j

        if eri_a.ndim == 2 and eri_b.ndim == 2 and eri_ab.ndim == 2:
            assert eri_a.shape == (npair, npair) and eri_b.shape == (npair, npair) and eri_ab.shape == (npair, npair)
            kl = 0
            for l in range(nmo):
                for k in range(0, l+1):
                    ij = 0
                    for i in range(0, nmo):
                        for j in range(0, i+1):
                            if i >= k:
                                if abs(eri_a[ij, kl]) > tol:
                                    fout.write(output_format % (eri_a[ij, kl], indx[i], indx[j], indx[k], indx[l]))
                            ij += 1
                    kl += 1
            fout.write(' 0.00000000000000000000E+00' + '     0     0     0     0\n')

            kl = 0
            for l in range(nmo):
                for k in range(0, l+1):
                    ij = 0
                    for i in range(0, nmo):
                        for j in range(0, i+1):
                            if i >= k:
                                if abs(eri_b[ij, kl]) > tol:
                                    fout.write(output_format % (eri_b[ij, kl], indx[i], indx[j], indx[k], indx[l]))
                            ij += 1
                    kl += 1
            fout.write(' 0.00000000000000000000E+00' + '     0     0     0     0\n')

            ij = 0
            for j in range(nmo):
                for i in range(0, j+1):
                    kl = 0
                    for k in range(nmo):
                        for l in range(0, k+1):
                            if abs(eri_ab[ij, kl]) > tol:
                                fout.write(output_format % (eri_ab[ij, kl], indx[i], indx[j], indx[k], indx[l]))
                            kl += 1
                    ij += 1
            fout.write(' 0.00000000000000000000E+00' + '     0     0     0     0\n')
            return

        # CASE B: full 4D arrays
        if eri_a.ndim == 4 and eri_b.ndim == 4 and eri_ab.ndim == 4:
            for i in range(nmo):
                for j in range(0, i + 1):
                    ij_idx = pair_index(i, j)
                    for k in range(nmo):
                        for l in range(0, k + 1):
                            kl_idx = pair_index(k, l)
                            if ij_idx >= kl_idx:
                                val = eri_a[i, j, k, l]
                                if abs(val) > tol:
                                    fout.write(output_format % (val, indx[i], indx[j], indx[k], indx[l]))
            fout.write(' 0.00000000000000000000E+00' + '     0     0     0     0\n')

            for i in range(nmo):
                for j in range(0, i + 1):
                    ij_idx = pair_index(i, j)
                    for k in range(nmo):
                        for l in range(0, k + 1):
                            kl_idx = pair_index(k, l)
                            if ij_idx >= kl_idx:
                                val = eri_b[i, j, k, l]
                                if abs(val) > tol:
                                    fout.write(output_format % (val, indx[i], indx[j], indx[k], indx[l]))
            fout.write(' 0.00000000000000000000E+00' + '     0     0     0     0\n')

            for i in range(nmo):
                for j in range(0, i + 1):
                    for k in range(nmo):
                        for l in range(0, k + 1):
                            val = eri_ab[i, j, k, l]
                            if abs(val) > tol:
                                fout.write(output_format % (val, indx[i], indx[j], indx[k], indx[l]))
            fout.write(' 0.00000000000000000000E+00' + '     0     0     0     0\n')
            return

        raise RuntimeError(f"Unsupported ERI shapes: eri_a {eri_a.shape}, eri_b {eri_b.shape}, eri_ab {eri_ab.shape}")
        
    def write_head(fout, nmo, nelec, ms=0, orbsym=None):
        is_uhf = isinstance(nelec, (list, tuple)) and len(nelec) == 2 and nelec[0] != nelec[1]
        if not isinstance(nelec, (int, np.number)):
            ms = abs(nelec[0] - nelec[1])
            nelec = nelec[0] + nelec[1]
        fout.write(' &FCI NORB=%4d,NELEC=%2d,MS2=%d,\n' % (nmo, nelec, ms))
        if orbsym is not None and len(orbsym) > 0:
            fout.write('  ORBSYM=%s\n' % ','.join([str(x) for x in orbsym]))
        else:
            fout.write('  ORBSYM=%s\n' % ('1,' * nmo))
        fout.write('  ISYM=1,\n')
        if is_uhf:
            fout.write('  IUHF=1,\n')
        fout.write(' &END\n')
    
    
    def write_head55(fout, nmo, nelec, ms=0, orbsym=None):
        if not isinstance(nelec, (int, np.number)):
            ms = abs(nelec[0] - nelec[1])
            nelec = nelec[0] + nelec[1]
        fout.write(f"{nmo:1d} {nelec:1d}\n")
        if orbsym is not None and len(orbsym) > 0:
            orbsym = [x + 1 for x in orbsym]
            fout.write(f"{' '.join([str(x) for x in orbsym])}\n")
        else:
            fout.write(f"{' 1' * nmo}\n")
        fout.write(' 150000\n')
    
    
    def from_integrals_uhf(filename, h1e_a, h1e_b, eri_a, eri_b, eri_ab, nmo, nelec, nuc=0, ms=0, orbsym=None,
                       tol=TOL, float_format=DEFAULT_FLOAT_FORMAT):
        with open(filename, 'w') as fout:
            if filename == 'fort.55':
                write_head55(fout, nmo, nelec, ms, orbsym)
            else:
                write_head(fout, nmo, nelec, ms, orbsym)
            write_eri_uhf(fout, eri_a, eri_b, eri_ab, nmo, tol=tol, float_format=float_format)
            write_hcore_uhf(fout, h1e_a, h1e_b, nmo, tol=tol, float_format=float_format)
            output_format = float_format + '     0     0     0     0\n'
            fout.write(output_format % nuc)
    
    from_integrals_uhf(filename, h1e_a, h1e_b, eri_a, eri_b, eri_ab, nmo_active, nelec_active, nuc + constant, 0, orbsym_active, tol=1e-18, float_format='% 0.20E')
    
if __name__ == '__main__':
    main()

#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Mhrzzs-MacBook-Air.local', release='25.0.0', version='Darwin Kernel Version 25.0.0: Wed Sep 17 21:38:03 PDT 2025; root:xnu-12377.1.9~141/RELEASE_ARM64_T8112', machine='arm64')  Threads 1
Python 3.11.10 (main, Sep  7 2024, 01:03:31) [Clang 16.0.0 (clang-1600.0.26.3)]
numpy 1.26.4  scipy 1.15.2  h5py 3.10.0
Date: Wed Oct 22 16:33:44 2025
PySCF version 2.6.2
PySCF path  /opt/homebrew/lib/python3.11/site-packages/pyscf

[CONFIG] ARGPARSE = False
[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/sv/p893skhd53z1sh_0fgwlc_0w0000gn/T
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = None
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 7
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 3
[INPUT] symmetry True subgroup D2h
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 N      0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] N
[INPUT] 0    0    [6    /1   ]  4173.51146        0.00183477216
                                627.457911        0.013994627
                                142.902093        0.06858655181
                                40.2343293        0.232240873
                                12.8202129        0.4690699481
                                4.39043701        0.3604551991
[INPUT] 0    0    [3    /1   ]  11.62636186       -0.1149611817
                                2.716279807       -0.1691174786
                                0.7722183966      1.145851947
[INPUT] 0    0    [1    /1   ]  0.2120314975         1
[INPUT] 1    0    [3    /1   ]  11.62636186       0.06757974388
                                2.716279807       0.3239072959
                                0.7722183966      0.7408951398
[INPUT] 1    0    [1    /1   ]  0.2120314975         1

nuclear repulsion = 0
point group symmetry = SO3, use subgroup D2h
symmetry origin: [0. 0. 0.]
symmetry axis x: [1. 0. 0.]
symmetry axis y: [0. 1. 0.]
symmetry axis z: [0. 0. 1.]
num. orbitals of irrep Ag = 3
num. orbitals of irrep B1u = 2
num. orbitals of irrep B2u = 2
num. orbitals of irrep B3u = 2
number of shells = 5
number of NR pGTOs = 22
number of NR cGTOs = 9
basis = {'N': [[0, [4173.51146, 0.00183477216], [627.457911, 0.013994627], [142.902093, 0.06858655181], [40.2343293, 0.232240873], [12.8202129, 0.4690699481], [4.39043701, 0.3604551991]], [0, [11.62636186, -0.1149611817], [2.716279807, -0.1691174786], [0.7722183966, 1.145851947]], [0, [0.2120314975, 1.0]], [1, [11.62636186, 0.06757974388], [2.716279807, 0.3239072959], [0.7722183966, 0.7408951398]], [1, [0.2120314975, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [4173.51146     627.457911    142.902093     40.2343293    12.8202129
    4.39043701]
bas 1, expnt(s) = [11.62636186  2.71627981  0.7722184 ]
bas 2, expnt(s) = [0.2120315]
bas 3, expnt(s) = [11.62636186  2.71627981  0.7722184 ]
bas 4, expnt(s) = [0.2120315]
CPU time:         2.27
arg.atm = [[ 7 20  1 23  0  0]]
arg.bas = [[ 0  0  6  1  0 24 30  0]
 [ 0  0  3  1  0 36 39  0]
 [ 0  0  1  1  0 42 43  0]
 [ 0  1  3  1  0 44 47  0]
 [ 0  1  1  1  0 50 51  0]]
arg.env = [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
  4.17351146e+03  6.27457911e+02  1.42902093e+02  4.02343293e+01
  1.28202129e+01  4.39043701e+00  2.40698494e+00  4.43266388e+00
  7.16197723e+00  9.37348857e+00  8.02923302e+00  2.76214918e+00
  1.16263619e+01  2.71627981e+00  7.72218397e-01 -1.82872803e+00
 -9.04033238e-01  2.38478175e+00  2.12031497e-01  7.89433060e-01
  1.16263619e+01  2.71627981e+00  7.72218397e-01  4.23258539e+00
  3.29513532e+00  1.56464681e+00  2.12031497e-01  4.19744359e-01]
ecpbas  = []


******** <class 'pyscf.scf.uhf_symm.SymAdaptedUHF'> ********
method = SymAdaptedUHF
initial guess = atom
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
diis_damp = 0
SCF conv_tol = 1e-14
SCF conv_tol_grad = None
SCF max_cycles = 9999
direct_scf = False
chkfile to save SCF result = out.chk
max_memory 4000 MB (current use 0 MB)
number electrons alpha = 5  beta = 2
irrep_nelec {'Ag': 4, 'B3u': 1, 'B2u': 1, 'B1u': 1}
Freeze 7 electrons in irreps ['Ag', 'B3u', 'B2u', 'B1u']
    0 free electrons in irreps 
cond(S) = 8.374051142376604
<class 'pyscf.scf.uhf_symm.SymAdaptedUHF'> does not have attributes  ddm_tol
Set gradient conv threshold to 1e-07
Spherically averaged atomic HF for {'N'}


******** <class '__main__.main.<locals>.CustomAtomSphAverageRHF'> ********
method = CustomAtomSphAverageRHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
diis_damp = 0
SCF conv_tol = 1e-09
SCF conv_tol_grad = None
SCF max_cycles = 9999
direct_scf = False
chkfile to save SCF result = /var/folders/sv/p893skhd53z1sh_0fgwlc_0w0000gn/T/tmpqwk3zgsv
max_memory 4000 MB (current use 0 MB)
atom = N
Set gradient conv threshold to 3.16228e-05
Initial guess from minao.
Nelec from initial guess = 6.997046677458153
E1 = -74.19781049103926  E_coul = 20.423609305773578
init E= -53.7742011852657
l = 0  e_0 = -15.5498614
l = 0  e_1 = -0.914316305
l = 0  e_2 = 1.00725408
l = 1  e_0 = -0.161148976
l = 1  e_1 = 0.955221529
    CPU time for initialize scf      0.01 sec, wall time      0.01 sec
l = 0  e_0 = -15.5498614
l = 0  e_1 = -0.914316305
l = 0  e_2 = 1.00725408
l = 1  e_0 = -0.161148976
l = 1  e_1 = 0.955221529
l = 0  occ = 2 + 0
l = 1  occ = 0 + 1
l = 2  occ = 0 + 0
l = 3  occ = 0 + 0
E1 = -72.96288162342516  E_coul = 19.14539737560618
cycle= 1 E= -53.817484247819  delta_E= -0.0433  |g|=    0  |ddm|= 0.389
    CPU time for cycle= 1      0.00 sec, wall time      0.00 sec
diis-norm(errvec)=0.182117
diis-c [-0.03316648  1.        ]
l = 0  e_0 = -15.8975298
l = 0  e_1 = -1.04065035
l = 0  e_2 = 0.921123745
l = 1  e_0 = -0.267774029
l = 1  e_1 = 0.865213229
l = 0  occ = 2 + 0
l = 1  occ = 0 + 1
l = 2  occ = 0 + 0
l = 3  occ = 0 + 0
E1 = -73.44811700051719  E_coul = 19.62565960668641
cycle= 2 E= -53.8224573938308  delta_E= -0.00497  |g|=    0  |ddm|= 0.166
    CPU time for cycle= 2      0.00 sec, wall time      0.00 sec
diis-norm(errvec)=0.0532655
diis-c [-3.03538295e-04  2.17322596e-01  7.82677404e-01]
l = 0  e_0 = -15.7933441
l = 0  e_1 = -1.00591185
l = 0  e_2 = 0.944591262
l = 1  e_0 = -0.234615167
l = 1  e_1 = 0.893672335
l = 0  occ = 2 + 0
l = 1  occ = 0 + 1
l = 2  occ = 0 + 0
l = 3  occ = 0 + 0
E1 = -73.31162708992012  E_coul = 19.488428672762936
cycle= 3 E= -53.8231984171572  delta_E= -0.000741  |g|=    0  |ddm|= 0.0409
    CPU time for cycle= 3      0.00 sec, wall time      0.00 sec
diis-norm(errvec)=0.00734034
diis-c [-1.88006836e-08 -8.39904506e-02 -1.41755612e-01  1.22574606e+00]
l = 0  e_0 = -15.7992525
l = 0  e_1 = -1.00901729
l = 0  e_2 = 0.942529796
l = 1  e_0 = -0.236247555
l = 1  e_1 = 0.892305084
l = 0  occ = 2 + 0
l = 1  occ = 0 + 1
l = 2  occ = 0 + 0
l = 3  occ = 0 + 0
E1 = -73.32129747772149  E_coul = 19.49809148028168
cycle= 4 E= -53.8232059974398  delta_E= -7.58e-06  |g|=    0  |ddm|= 0.00674
    CPU time for cycle= 4      0.00 sec, wall time      0.00 sec
diis-norm(errvec)=2.27018e-05
diis-c [-1.29844170e-10  9.92056768e-03  1.65341619e-02 -1.47515071e-01
  1.12106034e+00]
l = 0  e_0 = -15.7992156
l = 0  e_1 = -1.00898982
l = 0  e_2 = 0.942499742
l = 1  e_0 = -0.236228055
l = 1  e_1 = 0.892283875
l = 0  occ = 2 + 0
l = 1  occ = 0 + 1
l = 2  occ = 0 + 0
l = 3  occ = 0 + 0
E1 = -73.32131157306993  E_coul = 19.49810557558993
cycle= 5 E= -53.82320599748  delta_E= -4.02e-11  |g|=    0  |ddm|= 1.85e-05
    CPU time for cycle= 5      0.00 sec, wall time      0.00 sec
l = 0  e_0 = -15.7992156
l = 0  e_1 = -1.00899137
l = 0  e_2 = 0.942503798
l = 1  e_0 = -0.236228812
l = 1  e_1 = 0.8922872
l = 0  occ = 2 + 0
l = 1  occ = 0 + 1
l = 2  occ = 0 + 0
l = 3  occ = 0 + 0
E1 = -73.32130496827043  E_coul = 19.498098970789126
Extra cycle  E= -53.8232059974813  delta_E= -1.29e-12  |g|=    0  |ddm|= 2.74e-06
    CPU time for scf_cycle      0.01 sec, wall time      0.01 sec
    CPU time for SCF      0.01 sec, wall time      0.01 sec
Atomic HF for atom  N  converged. SCF energy = -53.8232059974813

Atom N, E = -53.8232059975
Nelec from initial guess = (3.5000000000000004, 3.5000000000000004)
E1 = -73.32130496827043  Ecoul = 19.498098970789126
init E= -53.8232059974813
    CPU time for initialize scf      0.01 sec, wall time      0.02 sec
alpha HOMO (B2u) = -0.236229405117651  LUMO (B3u) = 0.892286693433513
alpha irrep_nelec = [2, 1, 1, 1]
beta  irrep_nelec = [2, 0, 0, 0]
alpha-Ag nocc = 2  HOMO = -1.00899195493855  LUMO = 0.942503415648656
   mo_energy = [-15.79921745  -1.00899195   0.94250342]
alpha-B1u nocc = 1  HOMO = -0.236229405117652  LUMO = 0.892286693433513
   mo_energy = [-0.23622941  0.89228669]
alpha-B2u nocc = 1  HOMO = -0.236229405117651  LUMO = 0.892286693433514
   mo_energy = [-0.23622941  0.89228669]
alpha-B3u nocc = 1  HOMO = -0.236229405117651  LUMO = 0.892286693433513
   mo_energy = [-0.23622941  0.89228669]
beta-Ag nocc = 2  HOMO = -1.00899195493855  LUMO = 0.942503415648656
   mo_energy = [-15.79921745  -1.00899195   0.94250342]
beta-B1u nocc = 0
   mo_energy = [-0.23622941  0.89228669]
beta-B2u nocc = 0
   mo_energy = [-0.23622941  0.89228669]
beta-B3u nocc = 0
   mo_energy = [-0.23622941  0.89228669]
multiplicity <S^2> = 3.75  2S+1 = 4
E1 = -73.32130731644561  Ecoul = 18.960939714082766
cycle= 1 E= -54.3603676023628  delta_E= -0.537  |g|= 0.171  |ddm|= 0.809
    CPU time for cycle= 1      0.00 sec, wall time      0.00 sec
diis-norm(errvec)=0.241569
diis-c [-0.05835542  1.        ]
alpha HOMO (B1u) = -0.600753295222072  LUMO (B1u) = 0.815454681285829
alpha irrep_nelec = [2, 1, 1, 1]
beta  irrep_nelec = [2, 0, 0, 0]
alpha-Ag nocc = 2  HOMO = -1.20699920659577  LUMO = 0.885950349501247
   mo_energy = [-15.83443173  -1.20699921   0.88595035]
alpha-B1u nocc = 1  HOMO = -0.600753295222072  LUMO = 0.815454681285829
   mo_energy = [-0.6007533   0.81545468]
alpha-B2u nocc = 1  HOMO = -0.600753295222072  LUMO = 0.815454681285829
   mo_energy = [-0.6007533   0.81545468]
alpha-B3u nocc = 1  HOMO = -0.600753295222072  LUMO = 0.815454681285829
   mo_energy = [-0.6007533   0.81545468]
beta-Ag nocc = 2  HOMO = -0.811403988049545  LUMO = 0.99974831169777
   mo_energy = [-15.76427364  -0.81140399   0.99974831]
beta-B1u nocc = 0
   mo_energy = [0.11141043 0.9860035 ]
beta-B2u nocc = 0
   mo_energy = [0.11141043 0.9860035 ]
beta-B3u nocc = 0
   mo_energy = [0.11141043 0.9860035 ]
multiplicity <S^2> = 3.7506691  2S+1 = 4.0003346
E1 = -73.92088704363523  Ecoul = 19.538299424916044
cycle= 2 E= -54.3825876187192  delta_E= -0.0222  |g|= 0.0528  |ddm|= 0.199
    CPU time for cycle= 2      0.00 sec, wall time      0.00 sec
diis-norm(errvec)=0.0747305
diis-c [-0.00552179 -0.03572362  1.03572362]
alpha HOMO (B2u) = -0.561031449914734  LUMO (B2u) = 0.848931140471535
alpha irrep_nelec = [2, 1, 1, 1]
beta  irrep_nelec = [2, 0, 0, 0]
alpha-Ag nocc = 2  HOMO = -1.15408663681123  LUMO = 0.927334814350921
   mo_energy = [-15.66877926  -1.15408664   0.92733481]
alpha-B1u nocc = 1  HOMO = -0.561031449914734  LUMO = 0.848931140471536
   mo_energy = [-0.56103145  0.84893114]
alpha-B2u nocc = 1  HOMO = -0.561031449914734  LUMO = 0.848931140471535
   mo_energy = [-0.56103145  0.84893114]
alpha-B3u nocc = 1  HOMO = -0.561031449914734  LUMO = 0.848931140471535
   mo_energy = [-0.56103145  0.84893114]
beta-Ag nocc = 2  HOMO = -0.73534366612711  LUMO = 1.04949962448998
   mo_energy = [-15.58406572  -0.73534367   1.04949962]
beta-B1u nocc = 0
   mo_energy = [0.16349458 1.05735868]
beta-B2u nocc = 0
   mo_energy = [0.16349458 1.05735868]
beta-B3u nocc = 0
   mo_energy = [0.16349458 1.05735868]
multiplicity <S^2> = 3.752623  2S+1 = 4.0013113
E1 = -73.89439269008034  Ecoul = 19.50972185483252
cycle= 3 E= -54.3846708352478  delta_E= -0.00208  |g|= 0.0181  |ddm|= 0.071
    CPU time for cycle= 3      0.00 sec, wall time      0.00 sec
diis-norm(errvec)=0.0256378
diis-c [-8.70739880e-05 -6.25154610e-02 -3.23096811e-01  1.38561227e+00]
alpha HOMO (B3u) = -0.567524777875079  LUMO (B2u) = 0.845077750440578
alpha irrep_nelec = [2, 1, 1, 1]
beta  irrep_nelec = [2, 0, 0, 0]
alpha-Ag nocc = 2  HOMO = -1.15803164673031  LUMO = 0.926638887019222
   mo_energy = [-15.67676858  -1.15803165   0.92663889]
alpha-B1u nocc = 1  HOMO = -0.56752477787508  LUMO = 0.84507775044058
   mo_energy = [-0.56752478  0.84507775]
alpha-B2u nocc = 1  HOMO = -0.56752477787508  LUMO = 0.845077750440578
   mo_energy = [-0.56752478  0.84507775]
alpha-B3u nocc = 1  HOMO = -0.567524777875079  LUMO = 0.845077750440579
   mo_energy = [-0.56752478  0.84507775]
beta-Ag nocc = 2  HOMO = -0.726778596317372  LUMO = 1.05670649708217
   mo_energy = [-15.58678239  -0.7267786    1.0567065 ]
beta-B1u nocc = 0
   mo_energy = [0.16193527 1.05876207]
beta-B2u nocc = 0
   mo_energy = [0.16193527 1.05876207]
beta-B3u nocc = 0
   mo_energy = [0.16193527 1.05876207]
multiplicity <S^2> = 3.7543563  2S+1 = 4.0021775
E1 = -73.91933673422245  Ecoul = 19.534331149564032
cycle= 4 E= -54.3850055846584  delta_E= -0.000335  |g|= 0.00162  |ddm|= 0.0375
    CPU time for cycle= 4      0.00 sec, wall time      0.00 sec
diis-norm(errvec)=0.00229515
diis-c [-1.34633632e-06  1.03531175e-02  5.63928746e-02 -2.90248506e-01
  1.22350251e+00]
alpha HOMO (B2u) = -0.567431320470385  LUMO (B2u) = 0.844838140141338
alpha irrep_nelec = [2, 1, 1, 1]
beta  irrep_nelec = [2, 0, 0, 0]
alpha-Ag nocc = 2  HOMO = -1.15865819908465  LUMO = 0.926192670330945
   mo_energy = [-15.67665928  -1.1586582    0.92619267]
alpha-B1u nocc = 1  HOMO = -0.567431320470385  LUMO = 0.84483814014134
   mo_energy = [-0.56743132  0.84483814]
alpha-B2u nocc = 1  HOMO = -0.567431320470385  LUMO = 0.844838140141338
   mo_energy = [-0.56743132  0.84483814]
alpha-B3u nocc = 1  HOMO = -0.567431320470385  LUMO = 0.844838140141339
   mo_energy = [-0.56743132  0.84483814]
beta-Ag nocc = 2  HOMO = -0.725697916282385  LUMO = 1.05702514664482
   mo_energy = [-15.58582582  -0.72569792   1.05702515]
beta-B1u nocc = 0
   mo_energy = [0.16198719 1.05907145]
beta-B2u nocc = 0
   mo_energy = [0.16198719 1.05907145]
beta-B3u nocc = 0
   mo_energy = [0.16198719 1.05907145]
multiplicity <S^2> = 3.7545787  2S+1 = 4.0022887
E1 = -73.92110990069108  Ecoul = 19.536102225315986
cycle= 5 E= -54.3850076753751  delta_E= -2.09e-06  |g|= 0.000159  |ddm|= 0.00301
    CPU time for cycle= 5      0.00 sec, wall time      0.00 sec
diis-norm(errvec)=0.000225391
diis-c [-4.95746831e-10 -6.13799627e-04 -4.77932854e-03  2.94333209e-02
 -2.13470049e-01  1.18942986e+00]
alpha HOMO (B2u) = -0.567405707084073  LUMO (B3u) = 0.84490260729956
alpha irrep_nelec = [2, 1, 1, 1]
beta  irrep_nelec = [2, 0, 0, 0]
alpha-Ag nocc = 2  HOMO = -1.15872464406791  LUMO = 0.926162748714544
   mo_energy = [-15.67659177  -1.15872464   0.92616275]
alpha-B1u nocc = 1  HOMO = -0.567405707084075  LUMO = 0.844902607299561
   mo_energy = [-0.56740571  0.84490261]
alpha-B2u nocc = 1  HOMO = -0.567405707084073  LUMO = 0.844902607299563
   mo_energy = [-0.56740571  0.84490261]
alpha-B3u nocc = 1  HOMO = -0.567405707084074  LUMO = 0.84490260729956
   mo_energy = [-0.56740571  0.84490261]
beta-Ag nocc = 2  HOMO = -0.72568647429185  LUMO = 1.05709394637652
   mo_energy = [-15.58574746  -0.72568647   1.05709395]
beta-B1u nocc = 0
   mo_energy = [0.1620172  1.05911892]
beta-B2u nocc = 0
   mo_energy = [0.1620172  1.05911892]
beta-B3u nocc = 0
   mo_energy = [0.1620172  1.05911892]
multiplicity <S^2> = 3.7545941  2S+1 = 4.0022964
E1 = -73.92103503706592  Ecoul = 19.53602734449942
cycle= 6 E= -54.3850076925665  delta_E= -1.72e-08  |g|= 1.86e-06  |ddm|= 0.000246
    CPU time for cycle= 6      0.00 sec, wall time      0.00 sec
diis-norm(errvec)=2.62697e-06
diis-c [-2.04136529e-16  7.72688907e-06  1.61660683e-04 -8.93584361e-04
  6.30403656e-03 -4.01602493e-02  1.03458041e+00]
alpha HOMO (B2u) = -0.567405826039989  LUMO (B3u) = 0.844899981580654
alpha irrep_nelec = [2, 1, 1, 1]
beta  irrep_nelec = [2, 0, 0, 0]
alpha-Ag nocc = 2  HOMO = -1.15872624678382  LUMO = 0.926160762797405
   mo_energy = [-15.67659465  -1.15872625   0.92616076]
alpha-B1u nocc = 1  HOMO = -0.56740582603999  LUMO = 0.844899981580656
   mo_energy = [-0.56740583  0.84489998]
alpha-B2u nocc = 1  HOMO = -0.567405826039989  LUMO = 0.844899981580655
   mo_energy = [-0.56740583  0.84489998]
alpha-B3u nocc = 1  HOMO = -0.56740582603999  LUMO = 0.844899981580654
   mo_energy = [-0.56740583  0.84489998]
beta-Ag nocc = 2  HOMO = -0.725685463015892  LUMO = 1.05709087826637
   mo_energy = [-15.58575067  -0.72568546   1.05709088]
beta-B1u nocc = 0
   mo_energy = [0.16201587 1.05911708]
beta-B2u nocc = 0
   mo_energy = [0.16201587 1.05911708]
beta-B3u nocc = 0
   mo_energy = [0.16201587 1.05911708]
multiplicity <S^2> = 3.7545943  2S+1 = 4.0022965
E1 = -73.9210409662256  Ecoul = 19.53603327365716
cycle= 7 E= -54.3850076925684  delta_E= -1.94e-12  |g|= 2.35e-08  |ddm|= 2.35e-06
    CPU time for cycle= 7      0.00 sec, wall time      0.00 sec
diis-norm(errvec)=3.31941e-08
Linear dependence found in DIIS error vectors.
diis-c [-1.29907138e-15  3.87752697e-06  7.85384065e-05 -4.34937012e-04
  3.07020555e-03 -1.95134691e-02  4.99414951e-01  5.17380834e-01]
alpha HOMO (B2u) = -0.567405824415899  LUMO (B3u) = 0.844899995117956
alpha irrep_nelec = [2, 1, 1, 1]
beta  irrep_nelec = [2, 0, 0, 0]
alpha-Ag nocc = 2  HOMO = -1.15872623845888  LUMO = 0.926160771914435
   mo_energy = [-15.67659464  -1.15872624   0.92616077]
alpha-B1u nocc = 1  HOMO = -0.5674058244159  LUMO = 0.844899995117957
   mo_energy = [-0.56740582  0.8449    ]
alpha-B2u nocc = 1  HOMO = -0.567405824415899  LUMO = 0.844899995117957
   mo_energy = [-0.56740582  0.8449    ]
alpha-B3u nocc = 1  HOMO = -0.5674058244159  LUMO = 0.844899995117956
   mo_energy = [-0.56740582  0.8449    ]
beta-Ag nocc = 2  HOMO = -0.725685494861806  LUMO = 1.0570909119506
   mo_energy = [-15.58575066  -0.72568549   1.05709091]
beta-B1u nocc = 0
   mo_energy = [0.16201588 1.05911709]
beta-B2u nocc = 0
   mo_energy = [0.16201588 1.05911709]
beta-B3u nocc = 0
   mo_energy = [0.16201588 1.05911709]
multiplicity <S^2> = 3.7545943  2S+1 = 4.0022965
E1 = -73.92104092385695  Ecoul = 19.536033231288496
cycle= 8 E= -54.3850076925685  delta_E= -7.11e-15  |g|= 1.16e-08  |ddm|= 1.65e-08
    CPU time for cycle= 8      0.00 sec, wall time      0.00 sec
alpha HOMO (B2u) = -0.567405820324852  LUMO (B3u) = 0.844900010889623
alpha irrep_nelec = [2, 1, 1, 1]
beta  irrep_nelec = [2, 0, 0, 0]
alpha-Ag nocc = 2  HOMO = -1.15872622743676  LUMO = 0.926160783365504
   mo_energy = [-15.67659461  -1.15872623   0.92616078]
alpha-B1u nocc = 1  HOMO = -0.567405820324853  LUMO = 0.844900010889623
   mo_energy = [-0.56740582  0.84490001]
alpha-B2u nocc = 1  HOMO = -0.567405820324852  LUMO = 0.844900010889623
   mo_energy = [-0.56740582  0.84490001]
alpha-B3u nocc = 1  HOMO = -0.567405820324852  LUMO = 0.844900010889623
   mo_energy = [-0.56740582  0.84490001]
beta-Ag nocc = 2  HOMO = -0.725685519489799  LUMO = 1.05709094794847
   mo_energy = [-15.58575064  -0.72568552   1.05709095]
beta-B1u nocc = 0
   mo_energy = [0.16201588 1.05911711]
beta-B2u nocc = 0
   mo_energy = [0.16201588 1.05911711]
beta-B3u nocc = 0
   mo_energy = [0.16201588 1.05911711]
multiplicity <S^2> = 3.7545943  2S+1 = 4.0022965
E1 = -73.92104088103238  Ecoul = 19.536033188463918
Extra cycle  E= -54.3850076925685  delta_E= -1.42e-14  |g|= 2.92e-09  |ddm|= 1.38e-08
    CPU time for scf_cycle      0.03 sec, wall time      0.03 sec
    CPU time for SCF      0.03 sec, wall time      0.04 sec
converged SCF energy = -54.3850076925685  <S^2> = 3.7545943  2S+1 = 4.0022965
